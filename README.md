
# ğŸš€ Estruturas de Dados em Java â€“ Desafios Resolvidos

> RepositÃ³rio dedicado Ã  resoluÃ§Ã£o de **+50 exercÃ­cios de nÃ­vel mÃ©dio a avanÃ§ado** sobre Estruturas de Dados e uso da **Stream API** em Java.
> Este projeto Ã© resultado de prÃ¡tica intensa, foco em eficiÃªncia e aprimoramento de raciocÃ­nio lÃ³gico e tÃ©cnico.

---

## ğŸ§  Sobre o Projeto

Aqui explorei a fundo o funcionamento e a aplicaÃ§Ã£o das principais **estruturas de dados** da linguagem Java, com foco em:

* **OrganizaÃ§Ã£o de dados complexos**
* **Performance e eficiÃªncia de acesso**
* **ImplementaÃ§Ãµes prÃ¡ticas e comparativas**
* **Boas prÃ¡ticas e legibilidade do cÃ³digo**

Cada exercÃ­cio foi desenvolvido **sem dependÃªncias externas**, utilizando apenas recursos nativos da linguagem para consolidar o domÃ­nio da **API de Collections** e conceitos fundamentais de **algoritmos e estruturas de dados**.

---

## âš™ï¸ Estruturas e TÃ³picos Abordados

| Categoria                   | ConteÃºdo explorado                                             |
| --------------------------- | -------------------------------------------------------------- |
| ğŸ”¹ **Collections**          | List, Set, Map, TreeMap, HashMap, LinkedHashMap                |
| ğŸ”¹ **Estruturas de apoio**  | Queue, Deque, Stack, PriorityQueue                             |
| ğŸ”¹ **Grafos e Ãrvores**     | RepresentaÃ§Ãµes com Map, busca BFS/DFS, TreeSet, TreeMap        |
| ğŸ”¹ **Algoritmos clÃ¡ssicos** | OrdenaÃ§Ã£o, busca, contagem, ranking e filtragem                |
| ğŸ”¹ **Stream API**           | map, filter, reduce, collect, groupingBy e operaÃ§Ãµes paralelas |
| ğŸ”¹ **Boas prÃ¡ticas**        | Imutabilidade, eficiÃªncia, clareza e uso correto de Generics   |

---

## ğŸ§© Objetivo

> â€œEntender como cada estrutura funciona **por dentro** e saber **quando e por que** usÃ¡-la.â€

O principal objetivo Ã© demonstrar a capacidade de **pensar como engenheiro de software**, escolhendo a estrutura ideal para cada problema â€” algo essencial para qualquer **desenvolvedor back-end Java**.

---

## ğŸ§° Tecnologias

* â˜• **Java 17+**
* ğŸ§© **API de Collections**
* ğŸ” **Stream API**
* ğŸ§® **Paradigma funcional e imperativo**
* ğŸ§± **Estruturas implementadas do zero em alguns casos**

---

## ğŸ§ª Exemplos de ExercÃ­cios

* Contagem de elementos repetidos usando `Map`
* OrdenaÃ§Ã£o personalizada com `TreeSet` e `Comparator`
* SimulaÃ§Ã£o de filas com `Queue` e `Deque`
* Caminhos em grafos usando `Map<String, Set<String>>`
* Filtragem e agrupamento de dados com `Stream API`
* ImplementaÃ§Ã£o de uma `PriorityQueue` personalizada

---

## ğŸŒ± Aprendizados e PropÃ³sito

Cada soluÃ§Ã£o representa uma evoluÃ§Ã£o no meu domÃ­nio da linguagem e no entendimento de **como transformar lÃ³gica em performance**.
Meu objetivo nÃ£o Ã© apenas crescer tecnicamente, mas tambÃ©m **gerar valor real em projetos**, aplicando esses conhecimentos no desenvolvimento back-end de sistemas escalÃ¡veis.

---

## ğŸ“ˆ PrÃ³ximos Passos

* [ ] Adicionar benchmarking entre estruturas (`HashMap` vs `TreeMap`, etc.)
* [ ] Implementar estruturas do zero (`LinkedList`, `BinaryTree`, `Heap`)
* [ ] Adicionar interface grÃ¡fica simples para visualizaÃ§Ã£o de grafos

---

## ğŸ“¬ Contato

Se quiser trocar ideias, colaborar ou sugerir melhorias:

**ğŸ‘¤ InÃ¡cio Mazanga Milengo**
ğŸ“§ [[Email:](mailto:milengoinacio@gmail.com)]
ğŸ’¼ [LinkedIn](https://www.linkedin.com/in/immilengo)
ğŸ’» [GitHub](https://github.com/Immilengo)
